costRate = 2 // Science cost per level increases at this rate for every upgrade level
improvementRate = 0.899999976 // Part stat improvement per level diminishes by this factor for every upgrade level
batteryCharge // EC storage capacity for batteries
{
	scienceCost = 10 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 500 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.200000003 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
chargeRate // The EC rate generated from solar panels
{
	scienceCost = 10 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.0500000007 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
converterEfficiency // ISRU and Fuel Cell conversion efficiency
{
	scienceCost = 15 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.100000001 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
crashTolerance // Crash-tolerance for landing legs
{
	scienceCost = 10 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.150000006 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
dryMass // Dry mass (applies to every kind of part)
{
	scienceCost = 10 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 1 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = -0.100000001 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
fuelCapacity // Contained resource capacity
{
	scienceCost = 5 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 1000 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.0500000007 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
fuelFlow // Rate that fuel is consumed -- increases thrust
{
	scienceCost = 10 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.100000001 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
generatorEfficiency // Power output efficiency from reactors
{
	scienceCost = 15 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.100000001 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
ispAtm // I.S.P. in atmosphere
{
	scienceCost = 15 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.0500000007 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
ispVac // I.S.P. in vacuum
{
	scienceCost = 15 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.0500000007 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
maxTemperature // Maximum part temperature limit
{
	scienceCost = 5 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 1200 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.200000003 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
parachuteStrength // Parachute strength -- affects max speed when deploying
{
	scienceCost = 10 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 250 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.300000012 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
torque // Reaction-wheel torque power
{
	scienceCost = 5 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	costDivisor = 0 // scienceCost * (originalStat / costDivisor) * improvementRate^upgradeLevel
	improvement = 0.25 // originalStat * (1+(improvement * costRate^upgradeLevel))
}
